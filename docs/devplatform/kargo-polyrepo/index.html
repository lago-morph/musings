<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="How Kargo Keeps Things in Sync: - Warehouses watch multiple repositories - When changes are detected, Freight bundles are created - Each Freight contains specific versions (commits, tags, digests) of all subscribed artifacts - This bundle is promoted as an atomic unit Key Difference from Unified Versioning: - Unified tags: Everything shares one version → simple but inflexible - Kargo Freight: Each artifact has its own version, bundled together → flexible but more complex My Recommendation: For your scenario (Helm charts, Dockerfiles, and code in separate repos), I’d suggest: 1. Start with unified tagging + Kargo (hybrid approach) to get the best of both 2. Use Freight creation criteria to ensure compatible combinations 3."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lago-morph.github.io/musings/docs/devplatform/kargo-polyrepo/"><meta property="og:site_name" content="Technology Documentation Hub"><meta property="og:title" content="Response"><meta property="og:description" content="How Kargo Keeps Things in Sync: - Warehouses watch multiple repositories - When changes are detected, Freight bundles are created - Each Freight contains specific versions (commits, tags, digests) of all subscribed artifacts - This bundle is promoted as an atomic unit Key Difference from Unified Versioning: - Unified tags: Everything shares one version → simple but inflexible - Kargo Freight: Each artifact has its own version, bundled together → flexible but more complex My Recommendation: For your scenario (Helm charts, Dockerfiles, and code in separate repos), I’d suggest: 1. Start with unified tagging + Kargo (hybrid approach) to get the best of both 2. Use Freight creation criteria to ensure compatible combinations 3."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-16T00:00:00+00:00"><meta itemprop=name content="Response"><meta itemprop=description content="How Kargo Keeps Things in Sync: - Warehouses watch multiple repositories - When changes are detected, Freight bundles are created - Each Freight contains specific versions (commits, tags, digests) of all subscribed artifacts - This bundle is promoted as an atomic unit Key Difference from Unified Versioning: - Unified tags: Everything shares one version → simple but inflexible - Kargo Freight: Each artifact has its own version, bundled together → flexible but more complex My Recommendation: For your scenario (Helm charts, Dockerfiles, and code in separate repos), I’d suggest: 1. Start with unified tagging + Kargo (hybrid approach) to get the best of both 2. Use Freight creation criteria to ensure compatible combinations 3."><meta itemprop=datePublished content="2025-12-16T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-16T00:00:00+00:00"><meta itemprop=wordCount content="1271"><meta itemprop=keywords content="kargo,helm,yaml,container,deployment,orchestration,microservices,workflow"><title>Response | Technology Documentation Hub</title><link rel=icon href=/musings/favicon.png><link rel=manifest href=/musings/manifest.json><link rel=canonical href=https://lago-morph.github.io/musings/docs/devplatform/kargo-polyrepo/><link rel=stylesheet href=/musings/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG+T2l66Bw7pV8=" crossorigin=anonymous><script defer src=/musings/fuse.min.js></script><script defer src=/musings/en.search.min.5cc9128683126c7cda9fef74044c10c013f6d8935e1e3e719e3f562033e9ef44.js integrity="sha256-XMkShoMSbHzan+90BEwQwBP22JNeHj5xnj9WIDPp70Q=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/musings/><span>Technology Documentation Hub</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/musings/docs/ai-ml/>AI & Machine Learning</a><ul><li><a href=/musings/docs/ai-ml/agentic-computing-overview-and-tools/>Agentic Computing Overview And Tools</a></li><li><a href=/musings/docs/ai-ml/agno-vs-langchain/>Agno Vs Langchain</a></li><li><a href=/musings/docs/ai-ml/flowwise-vs-langflow/>Flowise vs Langflow: Detailed Comparison</a></li><li><a href=/musings/docs/ai-ml/one-model-multiple-diagrams/>Generate all views</a></li><li><a href=/musings/docs/ai-ml/verification-architecture/>Is This a Reasonable Architecture?</a></li><li><a href=/musings/docs/ai-ml/kiro-ide-comparison-tools/>Kiro IDE: Comprehensive Analysis, Comparisons & Optimal Workflows</a></li><li><a href=/musings/docs/ai-ml/langchain-architecture/>LangChain: The Foundation Library</a></li><li><a href=/musings/docs/ai-ml/llm-tracing-metrics-comparison/>Llm Tracing Metrics Comparison</a></li><li><a href=/musings/docs/ai-ml/kubernetes-based/>Open Source Workflow Orchestration on Kubernetes</a></li><li><a href=/musings/docs/ai-ml/tools-overview-and-getting-started/>Self-Hosted Open Source Agent Tools</a></li><li><a href=/musings/docs/ai-ml/serverless-function-workflow-tools-for-kubernetes/>Serverless/Function Workflows on Kubernetes</a></li><li><a href=/musings/docs/ai-ml/n8n-overview/>What Problems Does n8n Solve?</a></li></ul></li><li><a href=/musings/docs/devplatform/>Development Platforms</a><ul><li><a href=/musings/docs/devplatform/backstage-techdocs-pros-cons/>Backstage Techdocs Pros Cons</a></li><li><a href=/musings/docs/devplatform/cross-diagram-reuse-guide/>Cross-Diagram Domain Model Reuse in PlantUML</a></li><li><a href=/musings/docs/devplatform/prompt/>Crossplane EKS Management Cluster Implementation - Project Brief</a></li><li><a href=/musings/docs/devplatform/comprehensive-guide/>Driven vs Event: Comparison</a></li><li><a href=/musings/docs/devplatform/gitops-platform-safety/>GitOps Safety Architecture for Platform Evolution</a></li><li><a href=/musings/docs/devplatform/kargo-intro/>How Kargo Works with ArgoCD to Manage Deployments</a></li><li><a href=/musings/docs/devplatform/backstage-kratix-crossplane-argocd-blueprint/>Implementation Blueprint: Crossplane + Kratix + Backstage + ArgoCD</a></li><li><a href=/musings/docs/devplatform/kargo-git-tags/>In subsequent stages, you can read this metadata</a></li><li><a href=/musings/docs/devplatform/in-browser-editing-tools/>In-Browser Editing Documentation Solutions</a></li><li><a href=/musings/docs/devplatform/initial-comparison/>Initial Comparison</a></li><li><a href=/musings/docs/devplatform/kargo-argocd-interaction/>Kargo promotion step</a></li><li><a href=/musings/docs/devplatform/presentation/>Kargo: GitOps Promotion for ArgoCD</a></li><li><a href=/musings/docs/devplatform/notion-overview/>Notion: A Comprehensive Overview</a></li><li><a href=/musings/docs/devplatform/oss-portal-platform-orchestration-tools/>Oss Portal Platform Orchestration Tools</a></li><li><a href=/musings/docs/devplatform/oss-vs-closed-portal/>Oss Vs Closed Portal</a></li><li><a href=/musings/docs/devplatform/recommendations/>Overview of Text-Based UML Domain Modeling Tools</a></li><li><a href=/musings/docs/devplatform/export-conversion/>PlantUML Export & Embedding Options</a></li><li><a href=/musings/docs/devplatform/crossplane-solution/>Pseudocode for composition function</a></li><li><a href=/musings/docs/devplatform/kargo-polyrepo/ class=active>Response</a></li><li><a href=/musings/docs/devplatform/job-configmap-crossplane-abstraction/>Shell script helper for Option 3</a></li><li><a href=/musings/docs/devplatform/tasks/>Stage 1: Approach Overview & Comparison ✅ COMPLETE</a></li><li><a href=/musings/docs/devplatform/stage3-outline/>Stage 3: Implementation Patterns - Outline (Crossplane 2.1)</a></li></ul></li><li><a href=/musings/docs/infrastructure/>Infrastructure</a><ul><li><a href=/musings/docs/infrastructure/runbooks/>1. Mental Model Shift (Important Framing)</a></li><li><a href=/musings/docs/infrastructure/argocd-layered-values/>ArgoCD and Helm Schema Validation</a></li><li><a href=/musings/docs/infrastructure/prompt-guide/>Contents</a></li><li><a href=/musings/docs/infrastructure/overview/>Core Strategy: Progressive Delivery with Blast Radius Containment</a></li><li><a href=/musings/docs/infrastructure/stage1/>Crossplane EKS Management Cluster - Approach Overview & Comparison</a></li><li><a href=/musings/docs/infrastructure/getting-started-concise/>Getting Started Concise</a></li><li><a href=/musings/docs/infrastructure/ci-cd-templates/>GitHub Actions Example</a></li><li><a href=/musings/docs/infrastructure/k8s-mcp-servers/>K8s Mcp Servers</a></li><li><a href=/musings/docs/infrastructure/stage2/>Management Cluster VPC Layout</a></li><li><a href=/musings/docs/infrastructure/non-helm-schema-validation/>Non Helm Schema Validation</a></li><li><a href=/musings/docs/infrastructure/production-readiness-overview/>Production Readiness Guide: From Docker Compose to Kubernetes</a></li><li><a href=/musings/docs/infrastructure/schema-testing/>Quick Start: Generate Schema from Existing values.yaml</a></li><li><a href=/musings/docs/infrastructure/job-plus-configmap-annotation/>Read current state AND capture resourceVersion</a></li><li><a href=/musings/docs/infrastructure/layered-schema/>Schema Validation with Layered Values Files</a></li><li><a href=/musings/docs/infrastructure/helm-layered-abstraction/>Solution 2: Kustomize with Helm</a></li><li><a href=/musings/docs/infrastructure/starting-helm-testing/>Understanding What You're Testing</a></li><li><a href=/musings/docs/infrastructure/executive-summary/>What You're Building</a></li><li><a href=/musings/docs/infrastructure/devops-domain-model-guide/>Why This Approach Works for DevOps</a></li></ul></li><li><a href=/musings/docs/workflows/>Workflows</a><ul><li><a href=/musings/docs/workflows/imperitive-in-declarative/>Imperitive In Declarative</a></li></ul></li><li><a href=/musings/docs/mermaid-test/>Mermaid Diagram Test</a></li><li><a href=/musings/docs/misc/>Miscellaneous</a><ul></ul></li><li><a href=/musings/docs/test-document/>Test Document</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/musings/icons/menu.svg class=book-icon alt=Menu></label><h3>Response</h3><label for=toc-control><img src=/musings/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><ul><li><a href=#prompt>Prompt</a></li><li><a href=#response>Response</a></li><li><a href=#how-kargo-keeps-multi-repo-artifacts-in-sync>How Kargo Keeps Multi-Repo Artifacts in Sync</a><ul><li><a href=#the-core-mechanism-warehouses-create><strong>The Core Mechanism: Warehouses Create “Freight” Bundles</strong></a></li><li><a href=#example-your-multi-repo-scenario><strong>Example: Your Multi-Repo Scenario</strong></a></li></ul></li><li><a href=#how-this-differs-from-common-release-versioning><strong>How This Differs from Common Release Versioning</strong></a><ul><li><a href=#traditional-approach-unified-version-tags><strong>Traditional Approach: Unified Version Tags</strong></a></li><li><a href=#kargo-approach-artifact-bundles-freight><strong>Kargo Approach: Artifact Bundles (Freight)</strong></a></li></ul></li><li><a href=#the-compatibility-problem--solutions><strong>The Compatibility Problem & Solutions</strong></a><ul><li><a href=#the-race-condition-issue><strong>The Race Condition Issue</strong></a></li><li><a href=#kargo><strong>Kargo’s Solutions:</strong></a><ul><li><a href=#solution-1-freight-creation-criteria-newer-feature><strong>Solution 1: Freight Creation Criteria (Newer Feature)</strong></a></li><li><a href=#solution-2-multiple-warehouses-different-cadences><strong>Solution 2: Multiple Warehouses (Different Cadences)</strong></a></li><li><a href=#solution-3-gatekeeper-stage><strong>Solution 3: Gatekeeper Stage</strong></a></li></ul></li></ul></li><li><a href=#when-to-use-each-approach><strong>When to Use Each Approach</strong></a><ul><li><a href=#use-traditional-unified-versioning-when><strong>Use Traditional Unified Versioning When:</strong></a></li><li><a href=#use-kargo><strong>Use Kargo’s Freight-Based Approach When:</strong></a></li></ul></li><li><a href=#hybrid-approach-best-of-both-worlds><strong>Hybrid Approach (Best of Both Worlds)</strong></a></li><li><a href=#summary--recommendation><strong>Summary & Recommendation</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=prompt>Prompt<a class=anchor href=#prompt>#</a></h2><p>If I have helm charts in one repository, dockerfiles in another, and application code spread across multiple repositories how does kargo keep them all in sync? How does this differ from tagging all artifacts with a common release version?</p><h2 id=response>Response<a class=anchor href=#response>#</a></h2><p>Excellent question! This gets at the heart of how Kargo handles the complex reality of polyrepo architectures versus traditional release versioning. Let me search for specific information about Kargo&rsquo;s artifact tracking capabilities.Perfect! Now I have the detailed information needed. Let me provide a comprehensive answer.</p><h2 id=how-kargo-keeps-multi-repo-artifacts-in-sync>How Kargo Keeps Multi-Repo Artifacts in Sync<a class=anchor href=#how-kargo-keeps-multi-repo-artifacts-in-sync>#</a></h2><h3 id=the-core-mechanism-warehouses-create><strong>The Core Mechanism: Warehouses Create &ldquo;Freight&rdquo; Bundles</strong><a class=anchor href=#the-core-mechanism-warehouses-create>#</a></h3><p>A single Warehouse subscribes to repositories of all relevant artifacts, and each time it discovers a new revision of any or all of them, the Warehouse produces a new Freight resource referencing one revision of each. This is fundamentally different from traditional versioning.</p><p><strong>Here&rsquo;s the key insight:</strong> Kargo treats a &ldquo;release&rdquo; as a <strong>bundle of specific artifact versions</strong> (a Freight object), not as a single version number applied to everything.</p><h3 id=example-your-multi-repo-scenario><strong>Example: Your Multi-Repo Scenario</strong><a class=anchor href=#example-your-multi-repo-scenario>#</a></h3><p>Let&rsquo;s say you have:</p><ul><li><strong>App Code Repo A</strong>: Contains microservice-a → produces image <code>myapp/service-a:v1.2.3</code></li><li><strong>App Code Repo B</strong>: Contains microservice-b → produces image <code>myapp/service-b:v2.1.0</code></li><li><strong>Helm Charts Repo</strong>: Contains charts for both services</li><li><strong>Dockerfiles Repo</strong>: Contains build definitions</li></ul><p><strong>Warehouse Configuration:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-warehouse</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>my-project</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Subscribe to container images (built from your code repos)</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-a</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>semverConstraint</span>: <span style=color:#ae81ff>^1.0.0</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-b</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>semverConstraint</span>: <span style=color:#ae81ff>^2.0.0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Subscribe to Helm chart repository</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>chart</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://charts.example.com</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-chart</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>semverConstraint</span>: <span style=color:#ae81ff>^0.5.0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Subscribe to configuration Git repo</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>git</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/myorg/app-config.git</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>branch</span>: <span style=color:#ae81ff>main</span></span></span></code></pre></div><p><strong>What Happens:</strong>
When something new is discovered in any repository to which a warehouse subscribes, the warehouse produces a new piece of freight.</p><p><strong>Resulting Freight might look like:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Freight</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>freight-abc123</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>warehouse</span>: <span style=color:#ae81ff>my-app-warehouse</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>commits</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/myorg/app-config.git</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>id</span>: <span style=color:#ae81ff>7f4e8c2a9b1d3e5f6a8c9d0e1f2a3b4c5d6e7f8a</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>images</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-a</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>tag</span>: <span style=color:#ae81ff>v1.2.3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>digest</span>: <span style=color:#ae81ff>sha256:abcdef...</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-b  </span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>tag</span>: <span style=color:#ae81ff>v2.1.0</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>digest</span>: <span style=color:#ae81ff>sha256:123456...</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>charts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://charts.example.com</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-chart</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>version</span>: <span style=color:#ae81ff>0.5.2</span></span></span></code></pre></div><p><strong>This single Freight object now represents a testable, promotable unit</strong> containing:</p><ul><li>Specific image digests (not just tags)</li><li>Specific Git commit SHAs</li><li>Specific Helm chart versions</li></ul><p>Being referenced by a single Freight resource, these artifacts will be promoted from stage to stage together as a unit.</p><hr><h2 id=how-this-differs-from-common-release-versioning><strong>How This Differs from Common Release Versioning</strong><a class=anchor href=#how-this-differs-from-common-release-versioning>#</a></h2><p>Let me break down the key differences:</p><h3 id=traditional-approach-unified-version-tags><strong>Traditional Approach: Unified Version Tags</strong><a class=anchor href=#traditional-approach-unified-version-tags>#</a></h3><p><strong>What you described:</strong></p><ul><li>Tag everything with <code>v1.5.0</code></li><li>service-a image: <code>v1.5.0</code></li><li>service-b image: <code>v1.5.0</code></li><li>Helm chart: <code>v1.5.0</code></li><li>Git tag: <code>v1.5.0</code></li></ul><p><strong>Characteristics:</strong>
✅ <strong>Pros:</strong></p><ul><li>Simple mental model</li><li>Easy to communicate (&ldquo;deploy v1.5.0 to prod&rdquo;)</li><li>Clear version history</li></ul><p>❌ <strong>Cons:</strong></p><ul><li><strong>Tight coupling</strong>: All components must be versioned together, even if only one changed</li><li><strong>Build overhead</strong>: Every release requires rebuilding/re-tagging all artifacts</li><li><strong>Deployment inflexibility</strong>: Can&rsquo;t promote just a config change or just one service update</li><li><strong>Dependency on CI/CD</strong>: Requires sophisticated CI orchestration to tag everything consistently</li><li><strong>Hotfix complexity</strong>: Patching one component requires a new unified version across all</li></ul><h3 id=kargo-approach-artifact-bundles-freight><strong>Kargo Approach: Artifact Bundles (Freight)</strong><a class=anchor href=#kargo-approach-artifact-bundles-freight>#</a></h3><p><strong>What Kargo does:</strong></p><ul><li>Creates immutable bundles of specific artifact versions</li><li>service-a: <code>v1.2.3</code> (sha256:abc&mldr;)</li><li>service-b: <code>v2.1.0</code> (sha256:def&mldr;)</li><li>chart: <code>v0.5.2</code></li><li>config: <code>commit 7f4e8c2</code></li></ul><p><strong>Characteristics:</strong>
✅ <strong>Pros:</strong></p><ul><li><strong>Independent versioning</strong>: Each artifact maintains its own semantic version</li><li><strong>Selective promotion</strong>: Can promote config changes without rebuilding images</li><li><strong>State-driven</strong>: No need for CI to coordinate tags - Kargo discovers what exists</li><li><strong>Immutable references</strong>: Uses image digests, not just tags (tags can be overwritten)</li><li><strong>Flexible cadences</strong>: You can promote image revisions rapidly many times per day, while configuration changes are promoted more slowly with greater deliberation</li><li><strong>No rebuild required</strong>: Creating a new Freight doesn&rsquo;t require any new builds</li></ul><p>❌ <strong>Cons:</strong></p><ul><li><strong>Complexity</strong>: Harder to communicate (&ldquo;promote Freight abc123&rdquo;)</li><li><strong>Learning curve</strong>: Requires understanding Kargo&rsquo;s model</li><li><strong>Potential incompatibilities</strong>: Risk of bundling incompatible versions</li></ul><hr><h2 id=the-compatibility-problem--solutions><strong>The Compatibility Problem & Solutions</strong><a class=anchor href=#the-compatibility-problem--solutions>#</a></h2><h3 id=the-race-condition-issue><strong>The Race Condition Issue</strong><a class=anchor href=#the-race-condition-issue>#</a></h3><p>When there are multiple subscriptions, you may be subjected to race conditions when discovering an artifact in one subscription that is incompatible with the latest artifact in another subscription.</p><p><strong>Example Problem:</strong></p><ol><li>CI pushes <code>frontend:v2.0.0</code></li><li>Kargo discovers it immediately</li><li>Kargo creates Freight with <code>frontend:v2.0.0</code> + <code>backend:v1.5.0</code> (old version)</li><li>This combo is incompatible!</li><li>Later, <code>backend:v2.0.0</code> gets pushed, but Freight already exists</li></ol><h3 id=kargo><strong>Kargo&rsquo;s Solutions:</strong><a class=anchor href=#kargo>#</a></h3><h4 id=solution-1-freight-creation-criteria-newer-feature><strong>Solution 1: Freight Creation Criteria (Newer Feature)</strong><a class=anchor href=#solution-1-freight-creation-criteria-newer-feature>#</a></h4><p>Warehouses can now use expression-based criteria to control when automatic Freight creation occurs, solving the long-standing problem of Warehouses creating Freight with incompatible artifact combinations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>freightCreationPolicy</span>: <span style=color:#ae81ff>Automatic</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>freightCreationCriteria</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Only create Freight when frontend and backend tags match</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expression</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      imageFrom(&#39;myapp/frontend&#39;).Tag == imageFrom(&#39;myapp/backend&#39;).Tag</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/frontend</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/backend</span></span></span></code></pre></div><p><strong>Reasoning:</strong> This ensures Freight is only created when both frontend and backend have matching version tags, preventing incompatible combinations.</p><h4 id=solution-2-multiple-warehouses-different-cadences><strong>Solution 2: Multiple Warehouses (Different Cadences)</strong><a class=anchor href=#solution-2-multiple-warehouses-different-cadences>#</a></h4><p>Create separate Warehouse resources, with one subscribing to the container image repository and the other subscribing to a Git repository containing configuration, so each Stage effectively has two parallel pipelines.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># Fast-moving image Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>images-warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-a</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/service-b</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#75715e># Slow-moving config Warehouse  </span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config-warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>git</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/myorg/app-config.git</span></span></span></code></pre></div><p><strong>Reasoning:</strong> This allows you to promote images frequently while promoting configuration changes separately at a slower, more deliberate pace.</p><h4 id=solution-3-gatekeeper-stage><strong>Solution 3: Gatekeeper Stage</strong><a class=anchor href=#solution-3-gatekeeper-stage>#</a></h4><p>Create an initial stage that only allows compatible Freight to proceed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Stage</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>compatibility-gate</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>warehouse</span>: <span style=color:#ae81ff>my-warehouse</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>verification</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>analysisTemplates</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>compatibility-check</span></span></span></code></pre></div><p><strong>Reasoning:</strong> Test compatibility before allowing Freight to proceed to real environments.</p><hr><h2 id=when-to-use-each-approach><strong>When to Use Each Approach</strong><a class=anchor href=#when-to-use-each-approach>#</a></h2><h3 id=use-traditional-unified-versioning-when><strong>Use Traditional Unified Versioning When:</strong><a class=anchor href=#use-traditional-unified-versioning-when>#</a></h3><ul><li>You have a true monolith or tightly coupled services</li><li>All components genuinely need to change together</li><li>Your team is small and coordination is easy</li><li>Simplicity is more important than flexibility</li><li>Marketing/external communication needs simple version numbers</li></ul><h3 id=use-kargo><strong>Use Kargo&rsquo;s Freight-Based Approach When:</strong><a class=anchor href=#use-kargo>#</a></h3><ul><li>You have microservices or polyrepo architecture</li><li>Different components change at different rates</li><li>You want to decouple deployments from builds</li><li>You need to promote config changes without rebuilding</li><li>You want progressive delivery (canary, blue/green) with state tracking</li><li>You need strong audit trails of what&rsquo;s deployed where</li></ul><hr><h2 id=hybrid-approach-best-of-both-worlds><strong>Hybrid Approach (Best of Both Worlds)</strong><a class=anchor href=#hybrid-approach-best-of-both-worlds>#</a></h2><p>You can actually combine both approaches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>release-warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>freightCreationPolicy</span>: <span style=color:#ae81ff>Automatic</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>freightCreationCriteria</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Only create Freight when all artifacts have the same semver tag</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expression</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      imageFrom(&#39;myapp/frontend&#39;).Tag == 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      imageFrom(&#39;myapp/backend&#39;).Tag &amp;&amp;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      imageFrom(&#39;myapp/backend&#39;).Tag == 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      chartFrom(&#39;my-helm-chart&#39;).Version</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/frontend</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>allowTags</span>: <span style=color:#ae81ff>^v\d+\.\d+\.\d+$ </span> <span style=color:#75715e># Only semver tags</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>myapp/backend</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>allowTags</span>: <span style=color:#ae81ff>^v\d+\.\d+\.\d+$</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>chart</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://charts.example.com</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-chart</span></span></span></code></pre></div><p><strong>Benefits:</strong></p><ul><li>Your CI still tags everything with unified versions (v1.5.0)</li><li>Kargo only creates Freight when all components have matching versions</li><li>You get Kargo&rsquo;s promotion workflow and state tracking</li><li>You get the simplicity of unified version communication</li></ul><hr><h2 id=summary--recommendation><strong>Summary & Recommendation</strong><a class=anchor href=#summary--recommendation>#</a></h2><p><strong>How Kargo Keeps Things in Sync:</strong></p><ul><li>Warehouses watch multiple repositories</li><li>When changes are detected, Freight bundles are created</li><li>Each Freight contains specific versions (commits, tags, digests) of all subscribed artifacts</li><li>This bundle is promoted as an atomic unit</li></ul><p><strong>Key Difference from Unified Versioning:</strong></p><ul><li><strong>Unified tags</strong>: Everything shares one version → simple but inflexible</li><li><strong>Kargo Freight</strong>: Each artifact has its own version, bundled together → flexible but more complex</li></ul><p><strong>My Recommendation:</strong>
For your scenario (Helm charts, Dockerfiles, and code in separate repos), I&rsquo;d suggest:</p><ol><li><strong>Start with unified tagging + Kargo</strong> (hybrid approach) to get the best of both</li><li>Use Freight creation criteria to ensure compatible combinations</li><li>As your team matures, consider splitting into multiple Warehouses for different promotion cadences</li><li>Always use image digests in Freight (which Kargo does automatically) for immutability</li></ol><p><strong>Does this clarify the difference? Would you like me to dive deeper into any specific aspect or show you a complete working example for your specific repository structure?</strong></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/musings/docs/devplatform/crossplane-solution/ class="flex align-center"><img src=/musings/icons/backward.svg class=book-icon alt=Backward>
<span>Pseudocode for composition function</span>
</a></span><span><a href=/musings/docs/devplatform/job-configmap-crossplane-abstraction/ class="flex align-center"><span>Shell script helper for Option 3</span>
<img src=/musings/icons/forward.svg class=book-icon alt=Forward></a></span></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#prompt>Prompt</a></li><li><a href=#response>Response</a></li><li><a href=#how-kargo-keeps-multi-repo-artifacts-in-sync>How Kargo Keeps Multi-Repo Artifacts in Sync</a><ul><li><a href=#the-core-mechanism-warehouses-create><strong>The Core Mechanism: Warehouses Create “Freight” Bundles</strong></a></li><li><a href=#example-your-multi-repo-scenario><strong>Example: Your Multi-Repo Scenario</strong></a></li></ul></li><li><a href=#how-this-differs-from-common-release-versioning><strong>How This Differs from Common Release Versioning</strong></a><ul><li><a href=#traditional-approach-unified-version-tags><strong>Traditional Approach: Unified Version Tags</strong></a></li><li><a href=#kargo-approach-artifact-bundles-freight><strong>Kargo Approach: Artifact Bundles (Freight)</strong></a></li></ul></li><li><a href=#the-compatibility-problem--solutions><strong>The Compatibility Problem & Solutions</strong></a><ul><li><a href=#the-race-condition-issue><strong>The Race Condition Issue</strong></a></li><li><a href=#kargo><strong>Kargo’s Solutions:</strong></a><ul><li><a href=#solution-1-freight-creation-criteria-newer-feature><strong>Solution 1: Freight Creation Criteria (Newer Feature)</strong></a></li><li><a href=#solution-2-multiple-warehouses-different-cadences><strong>Solution 2: Multiple Warehouses (Different Cadences)</strong></a></li><li><a href=#solution-3-gatekeeper-stage><strong>Solution 3: Gatekeeper Stage</strong></a></li></ul></li></ul></li><li><a href=#when-to-use-each-approach><strong>When to Use Each Approach</strong></a><ul><li><a href=#use-traditional-unified-versioning-when><strong>Use Traditional Unified Versioning When:</strong></a></li><li><a href=#use-kargo><strong>Use Kargo’s Freight-Based Approach When:</strong></a></li></ul></li><li><a href=#hybrid-approach-best-of-both-worlds><strong>Hybrid Approach (Best of Both Worlds)</strong></a></li><li><a href=#summary--recommendation><strong>Summary & Recommendation</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>