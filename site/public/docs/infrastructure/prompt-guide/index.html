<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Production Readiness Deep-Dive Prompt Guide is a infrastructure document covering Production Readiness Deep-Dive Prompt Guide and How to Use This Guide. This resource provides information and guidance on the topic. See the full document for detailed information and implementation details."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lago-morph.github.io/musings/docs/infrastructure/prompt-guide/"><meta property="og:site_name" content="Technology Documentation Hub"><meta property="og:title" content="Contents"><meta property="og:description" content="Production Readiness Deep-Dive Prompt Guide is a infrastructure document covering Production Readiness Deep-Dive Prompt Guide and How to Use This Guide. This resource provides information and guidance on the topic. See the full document for detailed information and implementation details."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-16T00:00:00+00:00"><meta itemprop=name content="Contents"><meta itemprop=description content="Production Readiness Deep-Dive Prompt Guide is a infrastructure document covering Production Readiness Deep-Dive Prompt Guide and How to Use This Guide. This resource provides information and guidance on the topic. See the full document for detailed information and implementation details."><meta itemprop=datePublished content="2025-12-16T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-16T00:00:00+00:00"><meta itemprop=wordCount content="3120"><meta itemprop=keywords content="kubernetes,production,database,deployment,monitoring,observability,metrics,logging"><title>Contents | Technology Documentation Hub</title><link rel=icon href=/musings/favicon.png><link rel=manifest href=/musings/manifest.json><link rel=canonical href=https://lago-morph.github.io/musings/docs/infrastructure/prompt-guide/><link rel=stylesheet href=/musings/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG+T2l66Bw7pV8=" crossorigin=anonymous><script defer src=/musings/fuse.min.js></script><script defer src=/musings/en.search.min.5cc9128683126c7cda9fef74044c10c013f6d8935e1e3e719e3f562033e9ef44.js integrity="sha256-XMkShoMSbHzan+90BEwQwBP22JNeHj5xnj9WIDPp70Q=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/musings/><span>Technology Documentation Hub</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/musings/docs/ai-ml/>AI & Machine Learning</a><ul><li><a href=/musings/docs/ai-ml/agentic-computing-overview-and-tools/>Agentic Computing Overview And Tools</a></li><li><a href=/musings/docs/ai-ml/agno-vs-langchain/>Agno Vs Langchain</a></li><li><a href=/musings/docs/ai-ml/flowwise-vs-langflow/>Flowise vs Langflow: Detailed Comparison</a></li><li><a href=/musings/docs/ai-ml/one-model-multiple-diagrams/>Generate all views</a></li><li><a href=/musings/docs/ai-ml/verification-architecture/>Is This a Reasonable Architecture?</a></li><li><a href=/musings/docs/ai-ml/kiro-ide-comparison-tools/>Kiro IDE: Comprehensive Analysis, Comparisons & Optimal Workflows</a></li><li><a href=/musings/docs/ai-ml/langchain-architecture/>LangChain: The Foundation Library</a></li><li><a href=/musings/docs/ai-ml/llm-tracing-metrics-comparison/>Llm Tracing Metrics Comparison</a></li><li><a href=/musings/docs/ai-ml/kubernetes-based/>Open Source Workflow Orchestration on Kubernetes</a></li><li><a href=/musings/docs/ai-ml/tools-overview-and-getting-started/>Self-Hosted Open Source Agent Tools</a></li><li><a href=/musings/docs/ai-ml/serverless-function-workflow-tools-for-kubernetes/>Serverless/Function Workflows on Kubernetes</a></li><li><a href=/musings/docs/ai-ml/n8n-overview/>What Problems Does n8n Solve?</a></li></ul></li><li><a href=/musings/docs/devplatform/>Development Platforms</a><ul><li><a href=/musings/docs/devplatform/backstage-techdocs-pros-cons/>Backstage Techdocs Pros Cons</a></li><li><a href=/musings/docs/devplatform/cross-diagram-reuse-guide/>Cross-Diagram Domain Model Reuse in PlantUML</a></li><li><a href=/musings/docs/devplatform/prompt/>Crossplane EKS Management Cluster Implementation - Project Brief</a></li><li><a href=/musings/docs/devplatform/comprehensive-guide/>Driven vs Event: Comparison</a></li><li><a href=/musings/docs/devplatform/gitops-platform-safety/>GitOps Safety Architecture for Platform Evolution</a></li><li><a href=/musings/docs/devplatform/kargo-intro/>How Kargo Works with ArgoCD to Manage Deployments</a></li><li><a href=/musings/docs/devplatform/backstage-kratix-crossplane-argocd-blueprint/>Implementation Blueprint: Crossplane + Kratix + Backstage + ArgoCD</a></li><li><a href=/musings/docs/devplatform/kargo-git-tags/>In subsequent stages, you can read this metadata</a></li><li><a href=/musings/docs/devplatform/in-browser-editing-tools/>In-Browser Editing Documentation Solutions</a></li><li><a href=/musings/docs/devplatform/initial-comparison/>Initial Comparison</a></li><li><a href=/musings/docs/devplatform/kargo-argocd-interaction/>Kargo promotion step</a></li><li><a href=/musings/docs/devplatform/presentation/>Kargo: GitOps Promotion for ArgoCD</a></li><li><a href=/musings/docs/devplatform/notion-overview/>Notion: A Comprehensive Overview</a></li><li><a href=/musings/docs/devplatform/oss-portal-platform-orchestration-tools/>Oss Portal Platform Orchestration Tools</a></li><li><a href=/musings/docs/devplatform/oss-vs-closed-portal/>Oss Vs Closed Portal</a></li><li><a href=/musings/docs/devplatform/recommendations/>Overview of Text-Based UML Domain Modeling Tools</a></li><li><a href=/musings/docs/devplatform/export-conversion/>PlantUML Export & Embedding Options</a></li><li><a href=/musings/docs/devplatform/crossplane-solution/>Pseudocode for composition function</a></li><li><a href=/musings/docs/devplatform/kargo-polyrepo/>Response</a></li><li><a href=/musings/docs/devplatform/job-configmap-crossplane-abstraction/>Shell script helper for Option 3</a></li><li><a href=/musings/docs/devplatform/tasks/>Stage 1: Approach Overview & Comparison ✅ COMPLETE</a></li><li><a href=/musings/docs/devplatform/stage3-outline/>Stage 3: Implementation Patterns - Outline (Crossplane 2.1)</a></li></ul></li><li><a href=/musings/docs/infrastructure/>Infrastructure</a><ul><li><a href=/musings/docs/infrastructure/runbooks/>1. Mental Model Shift (Important Framing)</a></li><li><a href=/musings/docs/infrastructure/argocd-layered-values/>ArgoCD and Helm Schema Validation</a></li><li><a href=/musings/docs/infrastructure/prompt-guide/ class=active>Contents</a></li><li><a href=/musings/docs/infrastructure/overview/>Core Strategy: Progressive Delivery with Blast Radius Containment</a></li><li><a href=/musings/docs/infrastructure/stage1/>Crossplane EKS Management Cluster - Approach Overview & Comparison</a></li><li><a href=/musings/docs/infrastructure/getting-started-concise/>Getting Started Concise</a></li><li><a href=/musings/docs/infrastructure/ci-cd-templates/>GitHub Actions Example</a></li><li><a href=/musings/docs/infrastructure/k8s-mcp-servers/>K8s Mcp Servers</a></li><li><a href=/musings/docs/infrastructure/stage2/>Management Cluster VPC Layout</a></li><li><a href=/musings/docs/infrastructure/non-helm-schema-validation/>Non Helm Schema Validation</a></li><li><a href=/musings/docs/infrastructure/production-readiness-overview/>Production Readiness Guide: From Docker Compose to Kubernetes</a></li><li><a href=/musings/docs/infrastructure/schema-testing/>Quick Start: Generate Schema from Existing values.yaml</a></li><li><a href=/musings/docs/infrastructure/job-plus-configmap-annotation/>Read current state AND capture resourceVersion</a></li><li><a href=/musings/docs/infrastructure/layered-schema/>Schema Validation with Layered Values Files</a></li><li><a href=/musings/docs/infrastructure/helm-layered-abstraction/>Solution 2: Kustomize with Helm</a></li><li><a href=/musings/docs/infrastructure/starting-helm-testing/>Understanding What You're Testing</a></li><li><a href=/musings/docs/infrastructure/executive-summary/>What You're Building</a></li><li><a href=/musings/docs/infrastructure/devops-domain-model-guide/>Why This Approach Works for DevOps</a></li></ul></li><li><a href=/musings/docs/workflows/>Workflows</a><ul><li><a href=/musings/docs/workflows/imperitive-in-declarative/>Imperitive In Declarative</a></li></ul></li><li><a href=/musings/docs/mermaid-test/>Mermaid Diagram Test</a></li><li><a href=/musings/docs/misc/>Miscellaneous</a><ul></ul></li><li><a href=/musings/docs/test-document/>Test Document</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/musings/icons/menu.svg class=book-icon alt=Menu></label><h3>Contents</h3><label for=toc-control><img src=/musings/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#production-readiness-deep-dive-prompt-guide>Production Readiness Deep-Dive Prompt Guide</a><ul><li><a href=#how-to-use-this-guide>How to Use This Guide</a><ul><li><a href=#contents>Contents</a></li><li><a href=#usage-pattern>Usage Pattern</a></li><li><a href=#why-this-structure>Why This Structure?</a></li><li><a href=#tips-for-best-results>Tips for Best Results</a></li></ul></li><li><a href=#priming-prompt>Priming Prompt</a></li><li><a href=#topic-specific-prompts>Topic-Specific Prompts</a><ul><li><a href=#1-multi-replica-state-discovery-and-testing>1. Multi-Replica State Discovery and Testing</a></li><li><a href=#2-data-durability-and-backup-strategies>2. Data Durability and Backup Strategies</a></li><li><a href=#3-observability-architecture-for-operations>3. Observability Architecture for Operations</a></li><li><a href=#4-runbook-development-for-non-developer-operations>4. Runbook Development for Non-Developer Operations</a></li><li><a href=#5-bluegreen-deployment-implementation>5. Blue/Green Deployment Implementation</a></li><li><a href=#6-load-testing-strategy-and-execution>6. Load Testing Strategy and Execution</a></li><li><a href=#7-chaos-engineering-for-resilience-validation>7. Chaos Engineering for Resilience Validation</a></li><li><a href=#8-service-mesh-implementation-and-configuration>8. Service Mesh Implementation and Configuration</a></li><li><a href=#9-kubernetes-resource-management-and-sizing>9. Kubernetes Resource Management and Sizing</a></li><li><a href=#10-monitoring-and-alerting-design>10. Monitoring and Alerting Design</a></li><li><a href=#11-secrets-management-strategy>11. Secrets Management Strategy</a></li><li><a href=#12-configuration-management-across-environments>12. Configuration Management Across Environments</a></li><li><a href=#13-persistent-storage-strategy>13. Persistent Storage Strategy</a></li><li><a href=#14-database-connection-management>14. Database Connection Management</a></li><li><a href=#15-health-checks-and-readiness-probes>15. Health Checks and Readiness Probes</a></li><li><a href=#16-graceful-shutdown-and-pod-termination>16. Graceful Shutdown and Pod Termination</a></li><li><a href=#17-logging-strategy-for-distributed-systems>17. Logging Strategy for Distributed Systems</a></li><li><a href=#18-incident-response-and-post-mortems>18. Incident Response and Post-Mortems</a></li><li><a href=#19-pre-production-validation-gates>19. Pre-Production Validation Gates</a></li><li><a href=#20-capacity-planning-and-growth-management>20. Capacity Planning and Growth Management</a></li></ul></li><li><a href=#advanced-usage>Advanced Usage</a><ul><li><a href=#combining-prompts>Combining Prompts</a></li><li><a href=#requesting-specific-formats>Requesting Specific Formats</a></li><li><a href=#following-up-for-depth>Following Up for Depth</a></li><li><a href=#adapting-to-your-technology-stack>Adapting to Your Technology Stack</a></li></ul></li><li><a href=#prompt-maintenance>Prompt Maintenance</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=production-readiness-deep-dive-prompt-guide>Production Readiness Deep-Dive Prompt Guide<a class=anchor href=#production-readiness-deep-dive-prompt-guide>#</a></h1><h2 id=how-to-use-this-guide>How to Use This Guide<a class=anchor href=#how-to-use-this-guide>#</a></h2><p>This guide contains a collection of prompts designed to generate detailed, in-depth information on specific production readiness topics. The prompts are structured to work with AI assistants to produce comprehensive technical guidance.</p><h3 id=contents>Contents<a class=anchor href=#contents>#</a></h3><p>This prompt contains usage instructions explaining the pattern, one priming prompt to establish context for AI conversations, and 20 topic-specific prompts.</p><p>The prompts cover:</p><ul><li>Multi-replica testing</li><li>Data durability</li><li>Observability</li><li>Runbooks</li><li>Blue/green deployment</li><li>Load testing</li><li>Chaos engineering</li><li>Service mesh</li><li>Resource management</li><li>Monitoring/alerting</li><li>Secrets management</li><li>Configuration management</li><li>Persistent storage</li><li>Database connections</li><li>Health checks</li><li>Graceful shutdown</li><li>Logging strategy</li><li>Incident response</li><li>Pre-production validation</li><li>Capacity planning</li></ul><h3 id=usage-pattern>Usage Pattern<a class=anchor href=#usage-pattern>#</a></h3><ol><li><strong>Start a new conversation</strong> with your AI assistant for each topic area you want to explore</li><li><strong>Copy and paste the Priming Prompt</strong> (below) to establish context</li><li><strong>Copy and paste one or more Topic-Specific Prompts</strong> to get detailed guidance on that area</li><li><strong>Continue the conversation</strong> by asking follow-up questions or requesting clarifications</li><li><strong>Repeat</strong> with additional topic prompts in the same conversation if they&rsquo;re related</li></ol><h3 id=why-this-structure>Why This Structure?<a class=anchor href=#why-this-structure>#</a></h3><p>The priming prompt establishes who you are (experienced traditional ops professional), what you&rsquo;re doing (moving to Kubernetes), and what kind of information you need (actionable, vendor-neutral guidance). This context allows the topic-specific prompts to be concise while still generating high-quality, relevant responses.</p><h3 id=tips-for-best-results>Tips for Best Results<a class=anchor href=#tips-for-best-results>#</a></h3><ul><li><strong>Be specific in follow-ups</strong>: If a response is too high-level, ask for concrete examples or step-by-step procedures</li><li><strong>Request checklists</strong>: Ask for evaluation checklists or readiness assessments for each topic</li><li><strong>Ask for scenarios</strong>: Request specific failure scenarios or edge cases to consider</li><li><strong>Combine related topics</strong>: You can use multiple topic prompts in one conversation if they&rsquo;re closely related</li><li><strong>Adapt to your context</strong>: Mention your specific technologies (database type, programming languages) to get more targeted advice</li></ul><hr><h2 id=priming-prompt>Priming Prompt<a class=anchor href=#priming-prompt>#</a></h2><p>Copy and paste this prompt at the start of each new conversation to establish context:</p><pre tabindex=0><code>I am an experienced technical architect with a background in traditional Unix and PC server deployments. I&#39;m responsible for taking a microservices application that was developed and tested using docker-compose with single replicas of each service, and deploying it to production on a managed Kubernetes service in the cloud.

My goals are to:
- Ensure the application scales with load
- Make it robust under non-ideal conditions  
- Achieve data durability (resilient to application and hardware failures)
- Provide predictable, manageable operations for our Tier 2 operations team

Our operations model has three tiers:
- Tier 1: End users and their supervisors handle basic questions
- Tier 2: Operations platform personnel monitor systems and handle initial issue remediation
- Tier 3: My development and DevOps team handles complex issues and code changes

I want to minimize Tier 3 escalations by empowering Tier 2 with proper tools, documentation, runbooks, and observability.

We are using:
- Managed Kubernetes service (cloud provider)
- Cloud-managed databases (not databases running in Kubernetes)
- A platform-provided CI/CD pipeline with dev/staging/production environments
- Blue/green deployment strategy
- Service mesh (for traffic management and observability)

Please provide guidance that is:
- Vendor-neutral but acknowledges managed services context
- Actionable and practical, not just theoretical
- Focused on operational excellence and Tier 2 enablement
- Appropriate for someone experienced with traditional ops but new to distributed systems

I understand distributed systems concepts but need help translating them into concrete practices for my production environment.</code></pre><hr><h2 id=topic-specific-prompts>Topic-Specific Prompts<a class=anchor href=#topic-specific-prompts>#</a></h2><h3 id=1-multi-replica-state-discovery-and-testing>1. Multi-Replica State Discovery and Testing<a class=anchor href=#1-multi-replica-state-discovery-and-testing>#</a></h3><pre tabindex=0><code>Provide detailed guidance on testing whether my microservices are truly stateless and can run as multiple replicas. Our services have only been tested with single replicas in docker-compose.

Cover:
- Specific test scenarios that reveal hidden state dependencies
- How to design load tests that expose race conditions and concurrency issues
- What patterns to look for in code that indicate state problems (sessions, file I/O, caches, singletons)
- A testing progression plan (how many replicas to test with, for how long)
- Tools and techniques for discovering inter-pod dependencies
- How to validate that session management, file uploads, and caching work correctly with multiple replicas
- Common pitfalls when moving from 1 to N replicas

Include a checklist of specific tests to perform and questions to ask about the application architecture.</code></pre><h3 id=2-data-durability-and-backup-strategies>2. Data Durability and Backup Strategies<a class=anchor href=#2-data-durability-and-backup-strategies>#</a></h3><pre tabindex=0><code>Provide comprehensive guidance on protecting data durability in a Kubernetes environment where we use cloud-managed databases and may need persistent volumes for application data.

Cover:
- How to categorize data by criticality and choose appropriate protection strategies
- Backup strategies for cloud-managed databases (frequency, retention, testing)
- RPO and RTO definition and how to meet different requirements
- Persistent volume backup approaches for application data
- Object storage strategies for unstructured data (uploads, generated files)
- Disaster recovery planning and testing procedures
- How to validate that backups actually work (restore testing)
- Monitoring backup health and alerting on failures
- Documentation requirements for recovery procedures

Include a checklist for assessing current data protection posture and identifying gaps.</code></pre><h3 id=3-observability-architecture-for-operations>3. Observability Architecture for Operations<a class=anchor href=#3-observability-architecture-for-operations>#</a></h3><pre tabindex=0><code>Provide detailed guidance on building an observability system that enables Tier 2 operations personnel to diagnose and resolve issues without developer expertise.

Cover:
- What metrics to collect and why (the &#34;golden signals&#34; and beyond)
- Structured logging design for distributed systems (correlation IDs, log levels, JSON formatting)
- How to implement distributed tracing and when it&#39;s valuable
- Designing Grafana dashboards that answer operational questions
- What makes a dashboard useful vs. overwhelming for non-developers
- Alert design philosophy (what to alert on, how to write actionable alerts)
- Log aggregation and search strategies for troubleshooting
- How to make metrics, logs, and traces correlate for effective investigation
- Retention policies for metrics and logs

Include a checklist of observability capabilities needed and dashboard design principles.</code></pre><h3 id=4-runbook-development-for-non-developer-operations>4. Runbook Development for Non-Developer Operations<a class=anchor href=#4-runbook-development-for-non-developer-operations>#</a></h3><pre tabindex=0><code>Provide detailed guidance on creating effective runbooks that enable Tier 2 operations personnel to resolve issues independently.

Cover:
- The anatomy of an effective runbook (structure, required sections)
- How to write diagnosis steps that non-developers can follow
- How to write resolution procedures that are clear and safe
- When to escalate vs. when to remediate
- How to identify what runbooks you need (common failure patterns)
- Maintaining and updating runbooks based on incidents
- Linking runbooks to alerts and dashboards
- Examples of good vs. bad runbook content
- How to test runbooks with the operations team
- Creating an operations handbook as an overview document

Include templates for common runbook types and a checklist of runbook quality criteria.</code></pre><h3 id=5-bluegreen-deployment-implementation>5. Blue/Green Deployment Implementation<a class=anchor href=#5-bluegreen-deployment-implementation>#</a></h3><pre tabindex=0><code>Provide detailed guidance on implementing blue/green deployments for zero-downtime releases in Kubernetes.

Cover:
- How blue/green deployment works conceptually
- Why blue/green is valuable for mission-critical applications
- Implementation in Kubernetes (Services, labels, selectors)
- Managing database schema changes with blue/green (backward compatibility)
- Health check design for pre-traffic validation
- Rollback procedures and when to use them
- Monitoring during blue/green switches
- Communication and coordination process
- Handling stateful services in blue/green
- Cost implications of running two environments
- Integration with CI/CD pipelines

Include a checklist of blue/green readiness and a decision framework for when to rollback.</code></pre><h3 id=6-load-testing-strategy-and-execution>6. Load Testing Strategy and Execution<a class=anchor href=#6-load-testing-strategy-and-execution>#</a></h3><pre tabindex=0><code>Provide detailed guidance on load testing a distributed microservices application before production deployment.

Cover:
- Designing realistic load test scenarios (user patterns, traffic mix)
- How to establish performance baselines
- Progressive load testing (baseline → expected → peak → breaking point)
- What metrics to measure during load testing
- How long to run sustained load tests and why
- Identifying bottlenecks and resource constraints
- Testing auto-scaling behavior under load
- Load testing tools and approaches for Kubernetes
- Interpreting load test results and identifying problems
- When load testing indicates production readiness vs. more work needed

Include a checklist of load testing scenarios to execute and success criteria.</code></pre><h3 id=7-chaos-engineering-for-resilience-validation>7. Chaos Engineering for Resilience Validation<a class=anchor href=#7-chaos-engineering-for-resilience-validation>#</a></h3><pre tabindex=0><code>Provide detailed guidance on chaos engineering practices to validate system resilience before and after production deployment.

Cover:
- What chaos engineering is and why it&#39;s valuable
- Starting with chaos testing in non-production environments
- Types of failures to inject (pod kills, node failures, network issues, resource exhaustion, dependency failures)
- How to design chaos experiments (hypothesis, execution, observation)
- Tools for chaos testing in Kubernetes
- Measuring system resilience (recovery time, user impact)
- Building confidence to run chaos tests in production
- What to do when chaos tests reveal critical weaknesses
- Creating a chaos testing program (frequency, scope, evolution)
- Documenting chaos test results and improvements

Include a progression plan for chaos testing and a checklist of failure scenarios to validate.</code></pre><h3 id=8-service-mesh-implementation-and-configuration>8. Service Mesh Implementation and Configuration<a class=anchor href=#8-service-mesh-implementation-and-configuration>#</a></h3><pre tabindex=0><code>Provide detailed guidance on implementing and configuring a service mesh for traffic management, resilience, and observability.

Cover:
- What a service mesh is and what problems it solves
- When you need a service mesh vs. when it&#39;s overkill
- How service mesh works (sidecars, control plane, data plane)
- Key capabilities: traffic routing, retries, circuit breaking, timeouts, load balancing
- Observability benefits (distributed tracing, service-to-service metrics)
- Security features (mutual TLS, service identity)
- What application changes are needed to work with a service mesh
- Configuration patterns (timeouts, retry policies, circuit breakers)
- Operations implications (new debugging surface, configuration management)
- How to use service mesh observability tools for troubleshooting
- Training operations team on service mesh concepts

Include a checklist of service mesh readiness and configuration review points.</code></pre><h3 id=9-kubernetes-resource-management-and-sizing>9. Kubernetes Resource Management and Sizing<a class=anchor href=#9-kubernetes-resource-management-and-sizing>#</a></h3><pre tabindex=0><code>Provide detailed guidance on setting CPU and memory requests/limits for Kubernetes pods and planning cluster capacity.

Cover:
- Understanding requests vs. limits and how they affect scheduling
- How to determine appropriate resource values (load testing, monitoring)
- Consequences of under-provisioning (OOMKilled, throttling) and over-provisioning (waste, cost)
- Horizontal Pod Autoscaler (HPA) configuration and testing
- Vertical Pod Autoscaler (VPA) use cases
- Setting minimum and maximum replica counts
- Quality of Service (QoS) classes and their implications
- Node capacity planning and headroom
- Resource quota patterns for teams/namespaces
- Monitoring resource utilization vs. requests/limits

Include a checklist for resource sizing and a process for tuning based on production metrics.</code></pre><h3 id=10-monitoring-and-alerting-design>10. Monitoring and Alerting Design<a class=anchor href=#10-monitoring-and-alerting-design>#</a></h3><pre tabindex=0><code>Provide detailed guidance on designing monitoring and alerting that enables operations to detect and respond to issues effectively.

Cover:
- What to monitor (application, infrastructure, business metrics)
- Choosing the right metrics (signal vs. noise)
- Alert design principles (actionable, timely, contextual)
- Alert severity levels and when to use them
- Threshold tuning to minimize false positives
- Alert fatigue and how to avoid it
- Notification channels and escalation paths
- Alert messages: what to include, how to phrase them
- Linking alerts to runbooks and dashboards
- Testing alerting (triggering test alerts, validating delivery)
- Alert review and refinement process

Include a checklist of alerting best practices and an alert quality rubric.</code></pre><h3 id=11-secrets-management-strategy>11. Secrets Management Strategy<a class=anchor href=#11-secrets-management-strategy>#</a></h3><pre tabindex=0><code>Provide detailed guidance on managing secrets (passwords, API keys, certificates) in Kubernetes securely.

Cover:
- Kubernetes Secrets vs. external secret management systems
- Encryption at rest for Kubernetes Secrets
- RBAC for limiting secret access
- Secret rotation strategies and automation
- Mounting secrets as environment variables vs. volume mounts
- Integration with external secret managers (Vault, cloud secret services)
- Secrets in CI/CD pipelines (how to handle securely)
- Audit logging for secret access
- What to do when secrets are compromised
- Documentation of secret locations without exposing values
- Operations team secret access policies

Include a checklist of secret security practices and a secret rotation procedure template.</code></pre><h3 id=12-configuration-management-across-environments>12. Configuration Management Across Environments<a class=anchor href=#12-configuration-management-across-environments>#</a></h3><pre tabindex=0><code>Provide detailed guidance on managing application configuration across dev, staging, and production environments in Kubernetes.

Cover:
- ConfigMaps for non-sensitive configuration
- Structuring configuration (environment variables, files, both)
- Configuration per environment (dev, staging, production)
- Immutable configuration strategy (deploy new version vs. update in place)
- Configuration validation before deployment
- Version control for configuration
- How applications should consume configuration
- Handling configuration changes (do they require restarts?)
- Configuration documentation for operations
- Troubleshooting configuration issues

Include a checklist of configuration management best practices.</code></pre><h3 id=13-persistent-storage-strategy>13. Persistent Storage Strategy<a class=anchor href=#13-persistent-storage-strategy>#</a></h3><pre tabindex=0><code>Provide detailed guidance on using persistent volumes in Kubernetes for application data that must survive pod restarts.

Cover:
- When to use persistent volumes vs. object storage vs. external databases
- StatefulSets vs. Deployments for stateful services
- Storage classes and performance characteristics
- Provisioning persistent volumes (static vs. dynamic)
- Volume expansion and capacity planning
- Backup strategies for persistent volumes (snapshots, replication)
- Volume access modes (ReadWriteOnce, ReadWriteMany)
- Monitoring volume usage and alerting on capacity
- Handling volume failures and data recovery
- Persistent volume lifecycle (creation, attachment, deletion)

Include a checklist of persistent storage considerations and decision criteria.</code></pre><h3 id=14-database-connection-management>14. Database Connection Management<a class=anchor href=#14-database-connection-management>#</a></h3><pre tabindex=0><code>Provide detailed guidance on managing database connections from Kubernetes pods to avoid exhaustion and performance issues.

Cover:
- Why connection pooling matters in multi-replica environments
- Connection pool sizing (per pod, total across all pods)
- Connection pool configuration parameters (min, max, timeout, idle)
- Using connection pooling proxies (PgBouncer, ProxySQL)
- Monitoring database connections (active, idle, refused)
- What happens when connection limits are reached
- Database connection limits and how to adjust them
- Graceful handling of connection failures and retries
- Connection management during scaling events (pods starting/stopping)
- Load testing database connection behavior

Include a checklist of connection management configuration and a troubleshooting guide for connection issues.</code></pre><h3 id=15-health-checks-and-readiness-probes>15. Health Checks and Readiness Probes<a class=anchor href=#15-health-checks-and-readiness-probes>#</a></h3><pre tabindex=0><code>Provide detailed guidance on implementing health checks, liveness probes, and readiness probes in Kubernetes.

Cover:
- Difference between liveness, readiness, and startup probes
- What each probe type should check
- How Kubernetes uses probe results (traffic routing, restarts)
- Implementing health check endpoints in applications
- Probe configuration parameters (delay, timeout, period, threshold)
- Health check dependencies (database, external APIs)
- Avoiding cascading failures through health checks
- Testing health checks (simulating failures)
- Monitoring health check success rates
- Health checks during deployments and scaling

Include a checklist of health check implementation requirements and common mistakes to avoid.</code></pre><h3 id=16-graceful-shutdown-and-pod-termination>16. Graceful Shutdown and Pod Termination<a class=anchor href=#16-graceful-shutdown-and-pod-termination>#</a></h3><pre tabindex=0><code>Provide detailed guidance on implementing graceful shutdown in applications to avoid disrupting requests during pod termination.

Cover:
- Kubernetes pod termination lifecycle (SIGTERM, grace period, SIGKILL)
- Why graceful shutdown matters (avoiding failed requests during deployments)
- Implementing shutdown handlers in applications
- Draining in-flight requests before shutdown
- Handling long-running operations during shutdown
- PreStop hooks and when to use them
- Grace period configuration (how long is enough?)
- Connection draining from load balancers
- Testing graceful shutdown
- Monitoring shutdown behavior

Include a checklist of graceful shutdown implementation steps.</code></pre><h3 id=17-logging-strategy-for-distributed-systems>17. Logging Strategy for Distributed Systems<a class=anchor href=#17-logging-strategy-for-distributed-systems>#</a></h3><pre tabindex=0><code>Provide detailed guidance on implementing logging for distributed microservices that enables effective troubleshooting.

Cover:
- Structured logging (JSON format, consistent fields)
- Log levels and when to use each (ERROR, WARN, INFO, DEBUG)
- Correlation IDs for tracing requests across services
- What to include in every log entry (timestamp, service, pod, correlation ID)
- Log aggregation and centralization
- Log retention and storage costs
- Searching and filtering logs efficiently
- Avoiding log noise (what not to log)
- Performance implications of logging
- Log security (avoiding sensitive data in logs)
- Operations team log analysis training

Include a checklist of logging implementation requirements and log entry design guidelines.</code></pre><h3 id=18-incident-response-and-post-mortems>18. Incident Response and Post-Mortems<a class=anchor href=#18-incident-response-and-post-mortems>#</a></h3><pre tabindex=0><code>Provide detailed guidance on incident response processes and conducting effective post-mortem reviews.

Cover:
- Incident severity levels and classification
- Incident response roles (incident commander, communications, technical)
- Communication during incidents (who to notify, how often)
- Incident timeline tracking and documentation
- When to escalate and to whom
- Blameless post-mortem philosophy
- Conducting post-mortem meetings effectively
- Post-mortem documentation (what happened, why, how to prevent)
- Tracking action items from post-mortems
- Sharing lessons learned across teams
- Building incident response muscle through practice

Include an incident response checklist and a post-mortem template.</code></pre><h3 id=19-pre-production-validation-gates>19. Pre-Production Validation Gates<a class=anchor href=#19-pre-production-validation-gates>#</a></h3><pre tabindex=0><code>Provide detailed guidance on establishing validation gates that code must pass before production deployment.

Cover:
- Types of validation gates (automated tests, manual checks, approvals)
- Test coverage requirements for production readiness
- Performance testing gates (load test pass criteria)
- Security scanning and vulnerability thresholds
- Configuration validation
- Health check and smoke test validation
- Backup and restore testing requirements
- Runbook validation with operations team
- Staging environment validation duration
- Deployment checklist and sign-off process

Include a comprehensive pre-production checklist and gate criteria.</code></pre><h3 id=20-capacity-planning-and-growth-management>20. Capacity Planning and Growth Management<a class=anchor href=#20-capacity-planning-and-growth-management>#</a></h3><pre tabindex=0><code>Provide detailed guidance on capacity planning to ensure the system can handle growth without unexpected failures.

Cover:
- Establishing current capacity baseline
- Projecting future growth (users, data, traffic)
- Resource headroom philosophy (how much spare capacity?)
- Monitoring capacity utilization trends
- Triggers for capacity expansion (automated and manual)
- Scaling dimensions (replicas, nodes, storage, database)
- Cost implications of over-provisioning vs. under-provisioning
- Capacity testing (validating system at projected future load)
- Database capacity planning (storage, connections, query throughput)
- Network capacity considerations
- Quarterly capacity review process

Include a capacity planning worksheet and monitoring checklist.</code></pre><hr><h2 id=advanced-usage>Advanced Usage<a class=anchor href=#advanced-usage>#</a></h2><h3 id=combining-prompts>Combining Prompts<a class=anchor href=#combining-prompts>#</a></h3><p>You can combine related prompts in a single conversation. For example, after using the priming prompt:</p><ol><li>Use the &ldquo;Multi-Replica State Discovery&rdquo; prompt</li><li>Follow with the &ldquo;Load Testing Strategy&rdquo; prompt</li><li>Then use the &ldquo;Chaos Engineering&rdquo; prompt</li></ol><p>This creates a comprehensive testing and validation conversation.</p><h3 id=requesting-specific-formats>Requesting Specific Formats<a class=anchor href=#requesting-specific-formats>#</a></h3><p>When using topic prompts, you can request specific output formats:</p><ul><li>&ldquo;Provide this as a step-by-step implementation guide&rdquo;</li><li>&ldquo;Create this as a decision tree for troubleshooting&rdquo;</li><li>&ldquo;Format this as a training document for operations personnel&rdquo;</li><li>&ldquo;Give me this as a table comparing approaches&rdquo;</li><li>&ldquo;Provide example configurations or code samples&rdquo;</li></ul><h3 id=following-up-for-depth>Following Up for Depth<a class=anchor href=#following-up-for-depth>#</a></h3><p>After receiving a response to a topic prompt, dig deeper:</p><ul><li>&ldquo;Can you provide a specific example of [concept] in a [your context] environment?&rdquo;</li><li>&ldquo;What are the most common mistakes teams make with [topic]?&rdquo;</li><li>&ldquo;How would this approach differ if we were using [specific technology]?&rdquo;</li><li>&ldquo;Can you walk through a specific failure scenario and how to diagnose it?&rdquo;</li><li>&ldquo;What metrics or KPIs should we track for [topic]?&rdquo;</li></ul><h3 id=adapting-to-your-technology-stack>Adapting to Your Technology Stack<a class=anchor href=#adapting-to-your-technology-stack>#</a></h3><p>After the priming prompt, mention your specific technologies:</p><ul><li>&ldquo;We&rsquo;re using PostgreSQL as our database&rdquo;</li><li>&ldquo;Our services are written in Java with Spring Boot&rdquo;</li><li>&ldquo;We&rsquo;re on AWS EKS for Kubernetes&rdquo;</li><li>&ldquo;We use Istio as our service mesh&rdquo;</li></ul><p>This allows topic prompts to generate more specific, actionable guidance.</p><hr><h2 id=prompt-maintenance>Prompt Maintenance<a class=anchor href=#prompt-maintenance>#</a></h2><p>These prompts are designed to be relatively timeless, focusing on concepts and patterns rather than specific tool versions. However, you may want to:</p><ul><li>Add technology-specific variants for your environment</li><li>Create prompts for topics specific to your application domain</li><li>Evolve prompts based on what information proves most useful</li><li>Share and refine prompts across your team</li></ul><p>Consider the prompts as starting points that can be refined and customized for your organization&rsquo;s specific needs and context.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/musings/docs/infrastructure/argocd-layered-values/ class="flex align-center"><img src=/musings/icons/backward.svg class=book-icon alt=Backward>
<span>ArgoCD and Helm Schema Validation</span>
</a></span><span><a href=/musings/docs/infrastructure/overview/ class="flex align-center"><span>Core Strategy: Progressive Delivery with Blast Radius Containment</span>
<img src=/musings/icons/forward.svg class=book-icon alt=Forward></a></span></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#production-readiness-deep-dive-prompt-guide>Production Readiness Deep-Dive Prompt Guide</a><ul><li><a href=#how-to-use-this-guide>How to Use This Guide</a><ul><li><a href=#contents>Contents</a></li><li><a href=#usage-pattern>Usage Pattern</a></li><li><a href=#why-this-structure>Why This Structure?</a></li><li><a href=#tips-for-best-results>Tips for Best Results</a></li></ul></li><li><a href=#priming-prompt>Priming Prompt</a></li><li><a href=#topic-specific-prompts>Topic-Specific Prompts</a><ul><li><a href=#1-multi-replica-state-discovery-and-testing>1. Multi-Replica State Discovery and Testing</a></li><li><a href=#2-data-durability-and-backup-strategies>2. Data Durability and Backup Strategies</a></li><li><a href=#3-observability-architecture-for-operations>3. Observability Architecture for Operations</a></li><li><a href=#4-runbook-development-for-non-developer-operations>4. Runbook Development for Non-Developer Operations</a></li><li><a href=#5-bluegreen-deployment-implementation>5. Blue/Green Deployment Implementation</a></li><li><a href=#6-load-testing-strategy-and-execution>6. Load Testing Strategy and Execution</a></li><li><a href=#7-chaos-engineering-for-resilience-validation>7. Chaos Engineering for Resilience Validation</a></li><li><a href=#8-service-mesh-implementation-and-configuration>8. Service Mesh Implementation and Configuration</a></li><li><a href=#9-kubernetes-resource-management-and-sizing>9. Kubernetes Resource Management and Sizing</a></li><li><a href=#10-monitoring-and-alerting-design>10. Monitoring and Alerting Design</a></li><li><a href=#11-secrets-management-strategy>11. Secrets Management Strategy</a></li><li><a href=#12-configuration-management-across-environments>12. Configuration Management Across Environments</a></li><li><a href=#13-persistent-storage-strategy>13. Persistent Storage Strategy</a></li><li><a href=#14-database-connection-management>14. Database Connection Management</a></li><li><a href=#15-health-checks-and-readiness-probes>15. Health Checks and Readiness Probes</a></li><li><a href=#16-graceful-shutdown-and-pod-termination>16. Graceful Shutdown and Pod Termination</a></li><li><a href=#17-logging-strategy-for-distributed-systems>17. Logging Strategy for Distributed Systems</a></li><li><a href=#18-incident-response-and-post-mortems>18. Incident Response and Post-Mortems</a></li><li><a href=#19-pre-production-validation-gates>19. Pre-Production Validation Gates</a></li><li><a href=#20-capacity-planning-and-growth-management>20. Capacity Planning and Growth Management</a></li></ul></li><li><a href=#advanced-usage>Advanced Usage</a><ul><li><a href=#combining-prompts>Combining Prompts</a></li><li><a href=#requesting-specific-formats>Requesting Specific Formats</a></li><li><a href=#following-up-for-depth>Following Up for Depth</a></li><li><a href=#adapting-to-your-technology-stack>Adapting to Your Technology Stack</a></li></ul></li><li><a href=#prompt-maintenance>Prompt Maintenance</a></li></ul></li></ul></nav></div></aside></main></body></html>